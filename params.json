{
  "name": "Octopus",
  "tagline": "Offline calculation of particle trajectories",
  "body": "# Octopus\r\n##Offline calculation of Lagrangian trajectories\r\n\r\nThis model is in a development stage. Email me for questions.\r\n\r\nJinbo Wang <jinbow@gmail.com>\r\nScripps Institution of Oceanography\r\nAugust 26, 2015\r\n\r\n\r\nThere are two configurations: Lagrangian particle and Argo float. \r\n\r\nUse \"make\" to compile the code for Lagrangian particle simulation. Use \"make argo\" for simulating Argo float. \r\n\r\nBefore running the model, go to scripts folder and run \"python gen_data.py\" to compute the necessary data needed by the code.\r\n\r\n\r\n###Lagrangian particle simulation\r\n\r\n#### Steps to run:\r\n\r\nThe model is currently setup for the Southern Ocean State Estimate (SOSE). But it can be easily modified to fit any MITgcm output or any C-grid model output. To run the code, first make sure the model knows where to find your model output and correctly reads them. \r\n\r\n 1. Edit the parameters in **src/size.h** to fit the data you have.\r\n 1. Edit cpp_options.h to include or exclude features. Make sure **isArgo** is turned off in **cpp_options.h**: **#undef isArgo**\r\n 1. Within **src/** folder. Compile the code using\r\n     >make\r\n\r\n   You will get an executable file named **O.particle**.\r\n\r\n 1. Prepare the initialization file using **scritps/init_particl_xyz.py**. Copy the binary file to **src/**.\r\n 1. If you run particle with the SOSE 1/6th degree simulation, download necessary binary files:\r\n    >bash sync_data.sh\r\n\r\n    otherwise, go to scripts folder and run\r\n    >python gen_data.py\r\n\r\n    to generate the binary files.\r\n    \r\n 1. After running gen_data.py, you should get a list of binary files in your **pth_data_out** folder specified in **data.nml** including\r\n\r\n  1. reflect_x.bin\r\n  1. reflect_y.bin\r\n  1. z_to_k_lookup_table.bin\r\n  1. k_to_z_lookup_table.bin.\r\n\r\n 1. Set parameters in the namelist file **data.nml**. The parameters are explained line by line in **src/data.nml.explained**.\r\n 1. In the **src/** folder, run the model\r\n\r\n    >./O.particle\r\n\r\n 1. Outputs are saved in the folder  **output_dir** specified in **data.nml**.\r\n\r\n###Argo simulation\r\n\r\n#### Steps to run:\r\nMost of the steps are the same as for Lagrangian particle simulation with few exceptions. \r\n\r\n1. Make sure **isArgo** is defined in **cpp_options.h**:  **#define isArgo**\r\n1. Use *\"make argo\"*  to compile the code. \r\n1. You will get a executable **O.argo** after successfully compiling the code. \r\n1. Run the code using\r\n\r\n   >./O.argo\r\n\r\n###Parameterizations\r\n\r\n####Laplacian diffusion\r\n\r\nUse random walk to mimic the Laplacian diffusion. The random number with normal distribution is generated by **random.f90**. The value of the horizontal diffusion is set in **Khdiff** in **data.nml**.\r\n\r\n1. Before compiling the code, use **#define use_Laplacian_diffusion** in **cpp_options.h** to turn it on. \r\n1. Use **Khdiff** and **Kvdiff** to set the Laplacian diffusivity in horizontal and vertical, respectively. The unit is m^2/s.\r\n\r\n####Mixed Layer processes\r\n\r\n**Use this with caution**\r\n\r\nThis is a rather ad-hoc solution. No existing study has confirmed the robustness of this parameterization. \r\n\r\nThe idea is that the vertical mixing induced by mixed layer instability, which is usually parameterized by KPP (large et al. 1997), is missing for velocity-based Lagrangian trajectory integration. If we use particle density to represent passive tracers, we need to add random walk to particle position to mimic the parameterized vertical mixing in coarse resolution models. It is computationally too expensive to explicitly calculate the vertical mixing according to for example a K-profile of KPP. Our ad-hoc solution is to find particles within mixed layer and reshuffle them using a random-displacement model. \r\n\r\nThe model needs the following to run with mixed layer parameterization:\r\n\r\n1. turn on the parameterization in **cpp_options.h**: **#define use_mixedlayer_shuffle**\r\n1. prepare a data file with mixed layer depth (MLD)\r\n1. specific the parameters in **data.nml**\r\n 1. **fn_MLD='your mixed layer depth file name'**\r\n 1. **dt_mld=432000,** the time interval (in seconds) of the MLD data. For example, if you saved you MLD every 5 days, then **dt_mld=432000**\r\n\r\n####Meridional boundary condition\r\n\r\n1. Use **#define reflective_meridional_boundary** to turn on the reflective meridional boundaries. Particles will keep bouncing back to the domain.\r\n1. Use **#undef reflective_meridional_boundary** to turn it off. Particles will stay stagnant outside.\r\n\r\n####Zonal boundary condition\r\nRight now the zonal boundary condition is hard-coded as **periodic**.\r\n\r\n####Reflective continent\r\nOccasionally, particles enter continent, i.e., the dry cells. You can either keep them there or perform a rescue. \r\n\r\n1. Use **#define reflective_continent** to turn on reflective continent boundary condition. \r\n1. use **#undef reflective_continent** to turn it off. Particles will then stay stagnant once enter a dry grid cell. \r\n\r\n####Looping condition\r\n\r\nWith usually short duration of a numerical simulation, a common practice to obtain a Lagrangian simulation with a longer duration than the Eulerian fields is to loop the velocity from the starting point. This is rather a poor-man's solution, and strongly discouraged. However, if it is preferred, there are too options.\r\n\r\n1. Before compilation, use  **#define jump_looping** in **cpp_options.h** to turn on the jumping condition for looping, i.e., applying an artificial jump to make sure particle stay on the same isopycnal level before and after looping.\r\n1. Use **undef jump_looping** to turn it off. The code will just use the first step velocity to continue to advect particles once it reaches the end of the Eulerian field without doing anything on particle positions.\r\n\r\n\r\n\r\n\r\nGood luck!\r\n\r\n\r\nJinbo Wang\r\n\r\nApril 24, 2016\r\n\r\n##FAQ\r\n\r\n###compiling errors\r\n1. use \"make argo\" instead of \"make\" to compile if you got the following:\r\n\r\n >get_velocity.o: In function find_particle_uvw_:\r\n >get_velocity.f90:(.text+0xa01): undefined reference to get_argo_w_\r\n >collect2: error: ld returned 1 exit status\r\n >make: *** [opt] Error 1\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}